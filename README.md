# 一、需求分析

- [x] 两个选项之间的时间间隔设置**（s为单位）**
- [x] 两个小节之间的时间间隔设定**（比如刷题3s，我设置了10s，那么就一共需要等待13s，当然也可以选择设定两个区间的随机数值来进行刷课,最多20min,至少2min）**
- [x] 进入网页前自动判断网页是否已经刷完同时已经刷完了同时时间>=2min，则进入对应页面
- [x] 正常的 **5** 种类型试题可以刷完**（选择题、长空填词题、普通填词题、点击选词题、作文题）**
- [x] 每次刷题完成一个章节需要可以在一段类似于学习通刷题软件一样可以出现一个日志信息显示的小框框的小功能
- [ ] 可以自定义最终题目的正确率以便于实现老师的检查**（默认正确率100%，可能存在小偏差，但是问题不大）**
- [x] 如果老师不查，可以选择普通模式和极速模式，运行**5min以内（因为根据welearn源码发现它会每间隔1min来对网页查询，一共有多少个课程网页打开，如有多个，则会关闭）**将所有的页面全部刷完
- [x] 可以知晓日志信息，查看脚本正在做的事情**（样式2.0）** 



# 二、网站结构分析

1. **第一步：** 先分析网站属于什么类型的网站，这里说的类型主要分两种：**服务器渲染类型** 和 **客户端渲染类型**。

   - **第一种** 指的是服务器将数据和HTML结合在一起同意返回浏览器 
   - **第二种** 指的是第一次请求html，第二次请求数据，拿到数据再html中进行渲染
   - 本网站根据我的分析得出结论，它主要是**第一种**。

2. **第二步：** 再分析我们是否可以直接使用 **Python** 处理静态网站的方式直接获取**HTML**方式查看一下，是否可以获取到网站源码

   - 结论是肯定是，**不可以**，这里我们想通过分析 **HTML** 的方式来进行网站自动化填充工作，就肯定要使用到 **Selenium** 库用来处理这种动态网站**（其他库也行，自己看着办）**

   - **注意：** 该网站如果不熟悉动态反爬套路的话，大概率容易被摆了一刀，该网站将每个小节里面的内容都放到了一个**iframe**里面，导致一直无法获取到真正意义上的页面源码，浪费了很长时间：

     <img src="https://mogullzr001.oss-cn-beijing.aliyuncs.com/typora_img/202501032026790.png" alt="image-20250103145134116" style="zoom: 50%;" />

3. **第三步：** 这下就是开始分析网页结构了！！！这一步的话实际上就是找相同相似结构，下面是我针对于网站目前可以处理的**5种类型题目**的分析：

   - **选择题类型：** 一定存在 **div[data-controltype='choice']**
   - **长短文填充类型：** 一定存在 **[data-controltype='fillinglong']**
   - **普通填词类型：** 一定存在 **[data-controltype='filling']**
   - **点击填词类型：** 一定存在 **.ChooseBox.block_content.p**
   - **作文类型：** 一定存在 **.common_writing**
   - 如果以上都不是，那么就仅仅设置当前页面等待一段随机时间即可**（估计是3~7min之间的随机时间）**

4. **第四步：** 分析 **5（6）** 种类型题目的网页结构，对于每种题目都设置一种寻找答案的逻辑进行答案填充工作，下面是这 **5（6）** 种类型题目的填充逻辑分析：

   - **选择题类型：** 先找到 **ul[data-itemtype='options']** 这种结构的**HTML**元素从而获取到每道选择题的选项从而识别出谁才是正确答案然后点击即可。
   - **长短文填充类型：** 先找到 **[data-controltype='fillinglong']** 这种结构的 **HTML** 元素从而获取到每道题目输入框 **textarea[data-itemtype='textarea']**，然后识别到题目答案 **div[data-itemtype='result']** 再进行填充工作即可。
   - **普通填词类型：**  先找到 **[data-controltype='filling']** 这种结构的 **HTML** 元素从而获取到每道题目输入框 **input[data-itemtype='input']**，然后识别到题目答案 **div[data-itemtype='result']** 再进行填充工作即可。
   - **点击填词类型：**  先找到 **[data-controltype='filling']** 这种结构的 **HTML** 元素，**然后点击一下第一个缺口的按钮然后点击弹出选项的第一个位置的按钮（很绕，可以看下图）**，然后在下面的**第一次点击**的时候同样也设置为**点击第一次点击的位置**，因为每次点击下面弹出的单词的时候，焦点会自动跳转到下一道题目。
   - **作文类型：** 这个地方很简单，难点主要是调用AI的时候要学会组合出比较好的 **prompt** ，这才是最大的难点！这一部分就需要自主观看代码来感受了
   - **录音类型（暂定）：** 这个类型的题目难度就是最大的了，大概率是必须请出AI + 音频方面的大模型出手了，但是成本有点高，先不做。

# 三、初始化

### 0.准备购买一个deepseek接口

```
sk-ecee03845a1b42938fb66bae42694268
```

### 1.html2text**（html -> markdown语法）**

```bash
$ pip install html2text
```

### 2.OpenAI**（调用AI的库）**

```bash
$ pip3 install openai
```

### 3.selenium**（动态获取网页信息）**

```bash
$ pip install selenium
```

### 4.tkinter**（Python绘制GUI界面的库）**

```bash
$ pip install tkinter
```
